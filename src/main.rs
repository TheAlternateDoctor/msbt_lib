use std::{collections::HashMap, ffi::OsStr, fs::File, io::{Read, Write}, path::Path};

use msbt::msbt;
use ::msbt::msbt::MSBTString;
use clap::Parser;
use serde::{Deserialize, Serialize};
use serde_json;

#[derive(Parser, Debug)]
#[command(author, version, about, long_about = None)]
struct Args {
    /// Name of the file to open
    filename: String
}

#[derive(Serialize, Deserialize, Clone)]
struct MsbtJson {
    endianness:bool,
    strings:HashMap<String, String>
}

fn main() -> ::msbt::Result<()> {
    let cli = Args::parse();
    let extension = get_extension_from_filename(&cli.filename.clone()).unwrap().to_lowercase();
    let binding = cli.filename.clone();
    let filename = get_filename(&binding).unwrap();
    let mut file = File::open(cli.filename)?;
    if extension == "msbt" {
        let mut output_map = HashMap::new();
        let msbt = msbt::from_binary(&mut file)?;
        let strings = msbt::get_strings(msbt.clone())?;
        for string in strings {
            let mut parsed_string = ::msbt::structs::TXT2::parse_binary(string.string, msbt.endianness);
            parsed_string.truncate(parsed_string.len()-1);
            output_map.insert(string.label, parsed_string);
        }
        let order = match msbt.endianness {
            bytestream::ByteOrder::BigEndian => true,
            bytestream::ByteOrder::LittleEndian => false,
        };
        let msbt_json = MsbtJson{endianness: order, strings: output_map};
        let serialized = serde_json::to_string_pretty(&msbt_json).unwrap();
        println!("{:?}", serialized);
        let mut result = File::create(filename.to_owned()+".json")?;
        result.write(serialized.as_bytes())?;
    } else if extension == "json" {
        let json:MsbtJson = serde_json::from_reader(file)?;
        let mut strings = Vec::<MSBTString>::new();
        let mut i = 0;
        let order = match json.endianness {
            true => bytestream::ByteOrder::BigEndian,
            false => bytestream::ByteOrder::LittleEndian,
        };
        for (label, string) in json.strings{
            let corrected_string = string+"\0";
            strings.push(MSBTString{ index: i, label: label, string: ::msbt::structs::TXT2::parse_string(&corrected_string, order).unwrap() });
            i += 1;
        }
        let new_msbt = msbt::to_binary(strings, bytestream::ByteOrder::LittleEndian)?;
        let mut result = File::create(filename.to_owned()+".msbt")?;
        result.write(&new_msbt)?;
    }
    
    //Clappy Trio
    // let string = [0x0E, 0x00, 0x04, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0xCD, 0x50, 0x00, 0x72, 0x00, 0x65, 0x00, 0x73, 0x00, 0x73, 0x00, 0x20, 0x00, 0x00, 0xE0, 0x20, 0x00, 0x66, 0x00, 0x6F, 0x00, 0x72, 0x00, 0x20, 0x00, 0x74, 0x00, 0x68, 0x00, 0x65, 0x00, 0x20, 0x00, 0x74, 0x00, 0x68, 0x00, 0x69, 0x00, 0x72, 0x00, 0x64, 0x00, 0x20, 0x00, 0x63, 0x00, 0x6C, 0x00, 0x61, 0x00, 0x70, 0x00, 0x2E, 0x00, 0x0F, 0x00, 0x04, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x04, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x0E, 0x00, 0x04, 0x00, 0x00, 0x00, 0x02, 0x00, 0x01, 0xCD, 0x0E, 0x00, 0x00, 0x00, 0x03, 0x00, 0x04, 0x00, 0x3B, 0xDB, 0x3E, 0xFF, 0x54, 0x00, 0x61, 0x00, 0x70, 0x00, 0x0E, 0x00, 0x00, 0x00, 0x03, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x20, 0x00, 0x66, 0x00, 0x6F, 0x00, 0x72, 0x00, 0x20, 0x00, 0x74, 0x00, 0x68, 0x00, 0x65, 0x00, 0x20, 0x00, 0x74, 0x00, 0x68, 0x00, 0x69, 0x00, 0x72, 0x00, 0x64, 0x00, 0x20, 0x00, 0x63, 0x00, 0x6C, 0x00, 0x61, 0x00, 0x70, 0x00, 0x2E, 0x00, 0x0F, 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00];
    //Quiz Show
    // let string: [u8;118] = [0x54,0x00,0x68,0x00,0x65,0x00,0x20,0x00,0x6B,0x00,0x65,0x00,0x79,0x00,0x20,0x00,0x68,0x00,0x65,0x00,0x72,0x00,0x65,0x00,0x20,0x00,0x69,0x00,0x73,0x00,0x20,0x00,0x74,0x00,0x6F,0x00,0x20,0x00,0x0E,0x00,0x00,0x00,0x03,0x00,0x04,0x00,0xE4,0x00,0x00,0xFF,0x75,0x00,0x73,0x00,0x65,0x00,0x0A,0x00,0x74,0x00,0x68,0x00,0x65,0x00,0x20,0x00,0x72,0x00,0x68,0x00,0x79,0x00,0x74,0x00,0x68,0x00,0x6D,0x00,0x20,0x00,0x74,0x00,0x6F,0x00,0x20,0x00,0x72,0x00,0x65,0x00,0x6D,0x00,0x65,0x00,0x6D,0x00,0x62,0x00,0x65,0x00,0x72,0x00,0x0E,0x00,0x00,0x00,0x03,0x00,0x04,0x00,0x00,0x00,0x00,0xFF,0x21,0x00,0x00,0x00];
    // let constructed_string = ::msbt::structs::TXT2::parse_binary(string.to_vec(), bytestream::ByteOrder::LittleEndian);
    // println!("{}", constructed_string);

    // let string = "[RawCmd 4.0 00CD]Press [!A_button_3DS] for the third clap.[/RawCmd 4.0][RawCmd 4.1]\n[RawCmd 4.0 01CD][RawCmd 0.3 3BDB3EFF]Tap[RawCmd 0.3 000000FF] for the third clap.[/RawCmd 4.0]";
    // let constructed_string = ::msbt::structs::TXT2::parse_string(string, bytestream::ByteOrder::LittleEndian);

    // let code = "[/RawCmd 4.0]".to_string();
    // let raw_code = ::msbt::structs::TXT2::convert_control_code_close(&code, bytestream::ByteOrder::LittleEndian);
    // println!("{:02X?}", raw_code);
    Ok(())
}

fn get_extension_from_filename(filename: &str) -> Option<&str> {
    Path::new(filename)
        .extension()
        .and_then(OsStr::to_str)
}
fn get_filename(filename: &str) -> Option<&str> {
    Path::new(filename)
        .file_stem()
        .and_then(OsStr::to_str)
}